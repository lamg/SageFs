```
   â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„     â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ
  â–ˆâ–ˆâ–ˆ    â–ˆâ–€    â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–€    â–ˆâ–ˆâ–ˆ    â–ˆâ–€    â–ˆâ–ˆâ–ˆ    â–ˆâ–€    â–ˆâ–ˆâ–ˆ    â–ˆâ–€
  â–ˆâ–ˆâ–ˆ          â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–„â–ˆâ–ˆâ–ˆ         â–„â–ˆâ–ˆâ–ˆâ–„â–„â–„      â–„â–ˆâ–ˆâ–ˆâ–„â–„â–„       â–ˆâ–ˆâ–ˆ
â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–€â–€â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–„  â–€â–€â–ˆâ–ˆâ–ˆâ–€â–€â–€     â–€â–€â–ˆâ–ˆâ–ˆâ–€â–€â–€     â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
         â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–„    â–ˆâ–ˆâ–ˆ                 â–ˆâ–ˆâ–ˆ
   â–„â–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ           â–„â–ˆ    â–ˆâ–ˆâ–ˆ
 â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€    â–ˆâ–ˆâ–ˆ    â–ˆâ–€    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ         â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€

                 âš¡ Sage Mode for F# Development âš¡
```

# SageFs

**Sage Mode for F# development.** Enter a heightened state of awareness over your entire codebase.

SageFs is a live F# development server â€” a daemon that sees your code, understands your types, watches your files, streams to AI agents, and renders to any frontend. It's not just a REPL. It's the nervous system of your F# workflow.

[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![.NET](https://img.shields.io/badge/.NET-10.0-purple.svg)](https://dotnet.microsoft.com)

---

## ğŸš€ Quick Start

```bash
# Build from source
dotnet build -c Release
dotnet pack SageFs -c Release -o SageFs/nupkg

# Install globally
dotnet tool install -g --add-source ./SageFs/nupkg SageFs

# Run with a project or solution
sagefs --proj YourProject.fsproj
sagefs --sln YourSolution.sln

# Or just run (auto-detects .sln/.slnx/.fsproj in current dir)
sagefs
```

SageFs runs as a **daemon with a watchdog** â€” always alive, always watching. Everything else is a window into it:

- âœ… MCP server for AI agents (SSE push, not polling)
- âœ… File watcher with incremental `#load` reload (~100ms per change)
- âœ… Hot reloading â€” redefine functions, refresh browser
- âœ… Project dependencies loaded with iterative dependency resolution
- âœ… Shadow-copied assemblies (no DLL locks)
- âœ… Sub-process session management (Erlang-style supervisor)
- âœ… Code diagnostics and completions via MCP
- âœ… Watchdog keeps the daemon alive â€” crashes restart automatically

---

## âœ¨ Key Features

### ğŸ¤– **AI-Native Development (MCP)**

SageFs is built for AI-assisted development from the ground up. The MCP (Model Context Protocol) server runs automatically â€” AI agents receive live instructions explaining available capabilities, gated by session state. Tools appear and disappear based on what's actually possible right now.

```bash
# MCP SSE endpoint (for AI agents):
http://localhost:37749/sse
```

**MCP Tools:**
| Tool | Description |
|------|-------------|
| `send_fsharp_code` | Execute F# code in the REPL. Each `;;` marks a transaction boundary. |
| `check_fsharp_code` | Type-check code without executing. Returns compiler diagnostics. |
| `get_completions` | Get code completions at a cursor position. |
| `cancel_eval` | Cancel a running evaluation. |
| `load_fsharp_script` | Load and execute an `.fsx` file with partial progress preservation. |
| `get_recent_fsi_events` | View recent evaluations, errors, and script loads with timestamps. |
| `get_fsi_status` | Get session health, loaded projects, and statistics. |
| `get_startup_info` | Loaded projects, enabled features, and CLI arguments. |
| `get_available_projects` | Discover `.fsproj` and `.sln`/`.slnx` files in the working directory. |
| `reset_fsi_session` | Soft reset â€” fresh session, DLL locks retained. |
| `hard_reset_fsi_session` | Full reset â€” release DLL locks, optionally rebuild, fresh session. |
| `create_session` | Create a new isolated worker session (daemon mode). |
| `list_sessions` | List all active worker sessions with metadata. |
| `stop_session` | Stop a specific worker session by ID. |

**Tool Response Format:**

Every tool response leads with the submitted code, followed by the result or error with compiler diagnostics:

```
Code: let x = 42
Result: val x: int = 42
```

```
Code: let x = nonExistent()
Error: Operation could not be completed due to earlier error
Diagnostics:
  [error] The value or constructor 'nonExistent' is not defined.
```

**Console Echo:**

All code submitted via MCP tools or `/exec` is echoed to the visible terminal:

```
>
type Dog = {
  Name: string
  Breed: string
}
```

The `>` prompt appears on its own line, followed by the code with preserved indentation â€” fully copyable.

### ğŸ”„ **Hot Reloading**

Hot reloading works by redefining functions at runtime â€” changes take effect on the next browser refresh.

```fsharp
// Define a mutable handler
let mutable handleHome (ctx: HttpContext) =
    task {
        ctx.Response.ContentType <- "text/html"
        do! ctx.Response.WriteAsync("<h1>Hello, World!</h1>")
    }

// Later, redefine it in the REPL:
handleHome <- fun (ctx: HttpContext) ->
    task {
        ctx.Response.ContentType <- "text/html"
        do! ctx.Response.WriteAsync("<h1>Updated without restart!</h1>")
    }
;;
// Refresh browser - changes appear instantly! ğŸ”¥
```

See `test-hot-reload.fsx` for a complete working example.

### ğŸ‘ï¸ **File Watching & Incremental Reload**

SageFs watches your source files and automatically reloads changes via FSI `#load` â€” no restart, no hard reset. Changes take effect in ~100ms.

```mermaid
flowchart TD
    A[File Change Detected] --> B{Extension?}
    B -->|.fs / .fsx| C{Change Kind?}
    B -->|.fsproj| D[SoftReset<br/>New assembly refs needed]
    B -->|Other| E[Ignore]
    C -->|Changed / Created / Renamed| F{Excluded?}
    C -->|Deleted| E
    F -->|No| G["#load via FSI<br/>~100ms"]
    F -->|Yes| E
    G --> H{Result?}
    H -->|OK| I[Definitions Updated<br/>Session continues]
    H -->|Error| J[Error logged<br/>Old definitions remain valid]
```

**Key behaviors:**
- `.fs`/`.fsx` changes â†’ incremental `#load` (~100ms), not hard reset (30-60s)
- `.fsproj` changes â†’ soft reset (new assembly references needed)
- Failed `#load` is atomic â€” compile errors discard the load, old definitions remain valid
- Files in `bin/`, `obj/`, temp files (`~`, `.tmp`) are automatically excluded

**Controlling what's watched:**

```bash
# Disable file watching entirely
sagefs --no-watch

# Exclude patterns (glob syntax, planned)
# Uses same conventions as dotnet watch:
# <Watch Include="..." /> and Watch="false" in .fsproj
```

### ğŸ“¦ **Project & Solution Support**

SageFs automatically loads your project dependencies with smart warm-up:

```bash
sagefs --proj MyProject.fsproj  # Load one project
sagefs --sln MySolution.sln     # Load entire solution (.sln and .slnx supported)
sagefs                          # Auto-detect in current directory
```

**Warm-up features:**
- Iterative dependency resolution â€” retries failed opens after dependencies load
- `[<RequireQualifiedAccess>]` modules detected and skipped gracefully
- Shadow-copied assemblies prevent DLL locks on project files
- Progress displayed in real-time during namespace/module loading

### âš¡ **REPL Experience**

- Autocompletion and syntax highlighting (currently via PrettyPrompt â€” being replaced with custom rendering for multi-frontend support)
- Command history
- Multi-line editing

### ğŸ¯ **Computation Expression Simplification**

Top-level `let!` bindings in computation expressions are automatically transformed to work at the REPL.

### ğŸŒ **Aspire Project Detection**

SageFs detects .NET Aspire AppHost projects and auto-configures DCP/Dashboard paths. Hot reload won't work for orchestrated services (they run as separate processes). Load your F# web project directly instead:

```bash
# âœ… For hot reload:
sagefs --proj MyWebProject.fsproj

# âš ï¸ Limited (no hot reload for services):
sagefs --proj AppHost.fsproj
```

### ğŸ“ **Enhanced Directives**

```fsharp
#open MyModule.fs     // Import a file's open statements
:exec myFile.fs       // Execute a top-level program file
:e myFile.fs          // Short form of :exec
:pwd                  // Show current directory
:q                    // Quit
:help                 // Show help
```

---

## ğŸ“– Usage

### Basic Commands

```bash
sagefs                          # Start with auto-detection
sagefs --proj MyApp.fsproj      # Load specific project
sagefs --sln MySolution.sln     # Load entire solution
sagefs --use script.fsx         # Load and run script on startup
sagefs --help                   # Show all options
```

### MCP Configuration

```bash
sagefs                          # MCP on default port 37749
sagefs --mcp-port 8080          # Custom port
sagefs --no-mcp                 # Disable MCP server
```

### File Watching

```bash
sagefs                          # File watcher enabled by default
sagefs --no-watch               # Disable file watching
```

### Daemon Mode

```bash
sagefs -d                       # Start headless daemon (no REPL)
sagefs -d --proj MyApp.fsproj   # Daemon with project loaded
sagefs --bare                   # Bare session â€” no project/solution loading, quick startup
```

SageFs runs as a daemon by default â€” a headless server with MCP + HTTP endpoints and a **watchdog** that keeps it alive. If the process crashes, the watchdog restarts it automatically with exponential backoff.

Sub-process worker sessions can be created via MCP tools (`create_session`, `list_sessions`, `stop_session`). A `~/.SageFs/daemon.json` discovery file is written for client connections.

The REPL, terminal UI, web frontend, Neovim integration, and AI agents are all **clients** that connect to the running daemon â€” they don't embed SageFs, they talk to it.

### ASP.NET Features

```bash
sagefs                          # Auto-detect web frameworks
sagefs --no-web                 # Disable ASP.NET features
```

---

## ğŸ¤– AI Agent Configuration

### GitHub Copilot CLI

Add to your MCP config:

```json
{
  "mcpServers": {
    "SageFs": {
      "type": "sse",
      "url": "http://localhost:37749/sse",
      "headers": {},
      "tools": ["*"]
    }
  }
}
```

### Claude Desktop

Add to your MCP settings:

```json
{
  "mcpServers": {
    "SageFs": {
      "command": "SageFs",
      "args": [],
      "env": {}
    }
  }
}
```

---

## ğŸ§ª Testing

```bash
# Run all tests (uses Expecto â€” run via dotnet run, not dotnet test)
dotnet run --project SageFs.Tests

# Run specific test suites
dotnet run --project SageFs.Tests -- --filter "Snapshot"
dotnet run --project SageFs.Tests -- --filter "MCP Adapter"
dotnet run --project SageFs.Tests -- --filter "WarmUp"
```

Tests include:
- **Snapshot tests** (Verify) â€” locked-in output formats for echo, eval results, status
- **Property-based tests** (FsCheck via Expecto) â€” warm-up retry, statement splitting
- **Unit tests** â€” MCP adapter formatting, benign error detection, diagnostics
- **File watcher tests** â€” glob pattern matching, trigger/exclude logic, change action routing

---

## ğŸ—ï¸ Architecture

SageFs is a **daemon-first architecture**. The server is always the center â€” every frontend is a client.

```
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚  Watchdog   â”‚
                          â”‚  (restart)  â”‚
                          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚ monitors
                          â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ SageFs      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚           â”‚ Daemon      â”‚           â”‚
              â”‚           â””â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”˜           â”‚
              â”‚              â”‚   â”‚   â”‚              â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â–¼â”€â” â”‚ â”Œâ”€â–¼â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
         â”‚Terminal â”‚   â”‚ Web   â”‚ â”‚ â”‚Neovim â”‚   â”‚ VSCode â”‚
         â”‚ REPL   â”‚   â”‚(SSE)  â”‚ â”‚ â”‚Client â”‚   â”‚ Client â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                          â”‚ AI Agents â”‚
                          â”‚  (MCP)    â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### How It Works

1. **Daemon Process** â€” The core. Runs FSI engine, MCP server, file watcher, hot reload. Managed by a watchdog that auto-restarts on crash with exponential backoff.
2. **Worker Sessions** â€” Isolated FSI sessions spawned as sub-processes, supervised Erlang-style by the SessionManager.
3. **Clients** â€” REPL, web UI, Neovim, VSCode, AI agents all connect to the daemon via MCP/HTTP/SSE. They don't embed SageFs â€” they're windows into it.

There is no "embedded mode". The daemon IS SageFs.

Core components:
- **F# Interactive Engine** â€” FCS-based eval with middleware pipeline
- **MCP Server** â€” HTTP/SSE endpoints for AI agents and clients
- **Watchdog** â€” Monitors daemon health, restarts on crash with backoff
- **SessionManager** â€” Erlang-style supervisor: spawn/monitor/restart worker sessions
- **Affordance State Machine** â€” `SessionState` DU controls tool availability per lifecycle phase
- **File Watcher** â€” Incremental `#load` reload on `.fs`/`.fsx` changes (~100ms)
- **Hot Reload Engine** â€” Runtime function redefinition
- **Project Loader** â€” Ionide.ProjInfo for dependency resolution
- **Shadow Copy** â€” Assemblies copied to temp dir to prevent DLL locks
- **DDD Type Safety** â€” `SageFsError`, `SessionMode`, `CompletionKind`, `SessionStatus`, `DiagnosticSeverity` DUs

---

## ğŸ“Š Project Status

**Target Framework**: .NET 10.0
**Stability**: Active development â€” 400 tests passing
**Test Framework**: Expecto + Verify snapshots + FsCheck property tests

### What's Done
- âœ… Daemon with sub-process worker sessions
- âœ… SessionManager (Erlang-style supervisor with exponential backoff restart)
- âœ… MCP server with 14 tools (eval, diagnostics, completions, session management)
- âœ… Affordance-driven state machine (tools gated by session lifecycle)
- âœ… DDD type safety (SageFsError, SessionMode, CompletionKind, SessionStatus DUs)
- âœ… Elm Architecture core â€” SageFsMsg, SageFsModel, SageFsUpdate, SageFsRender, SageFsEffectHandler
- âœ… SageFsEffectHandler â€” bridges pure Elm loop to SessionManager/worker infrastructure
- âœ… Collectible AssemblyLoadContext for namespace discovery (prevents stale DLLs after rebuild)
- âœ… Build timeout (120s) prevents hard reset from hanging forever
- âœ… File watcher with incremental `#load` reload (~100ms, not hard reset)
- âœ… Hot reload (redefine functions, refresh to see changes)
- âœ… Project/solution loading (`.fsproj`, `.sln`, `.slnx`)
- âœ… Shadow-copy DLL lock prevention
- âœ… Event sourcing with Marten (when `SAGEFS_CONNECTION_STRING` set)
- âœ… Code diagnostics and autocomplete via MCP
- âœ… Eval cancellation
- âœ… Console echo for all MCP/exec submissions
- âœ… Aspire project detection and configuration
- âœ… Core domain types: Editor, ElmLoop, RenderPipeline, SageFsEvent, SageFsView
- âœ… SessionDisplay types for UI rendering

### What's Next
- ğŸ”² Wiring ElmLoop to daemon â€” connect SageFsEffectHandler dispatch to live SessionManager
- ğŸ”² Watchdog process for daemon auto-restart
- ğŸ”² Remove embedded mode â€” daemon-only architecture
- ğŸ”² REPL as a client connecting to daemon
- ğŸ”² Replace PrettyPrompt with custom rendering â€” PrettyPrompt assumes it owns the terminal and can't render into a grid region, making it incompatible with the multi-frontend architecture

### Where It's Going

SageFs is evolving into a **multi-frontend immediate-mode architecture** â€” a single core engine that serves terminal, web (Datastar SSE), Neovim, VSCode, and GPU (Raylib/ImGui) frontends through one unified event bus.

**Architectural pillars:**
- **Custom Elm loop** â€” `update : Msg -> Model -> Model * Effect list`, pure F#, no framework dependency. `SageFsEffectHandler` bridges pure state updates to real infrastructure (SessionManager, worker proxies)
- **Immediate-mode rendering** â€” `UI = render(state)`, no retained widget trees
- **Affordance-driven HATEOAS** â€” every element carries its possible actions; domain decides what's *possible*, adapters decide how to *render*
- **Tree-sitter foundation** â€” `ionide/tree-sitter-fsharp` for syntax highlighting and structural navigation
- **Push-based reactive streaming** â€” single `SageFsEvent` bus, all frontends subscribe via `IObservable<SageFsEvent>`
- **Neovim-inspired UI protocol** â€” draw primitives + grid regions, frontend-agnostic rendering

The goal: you write F# domain logic once, and SageFs renders it everywhere â€” terminal, browser, editor, GPU window. Sage Mode sees all.

See [docs/repl-tui-research.md](docs/repl-tui-research.md) for the full research document.

---

## ğŸ“œ License

MIT License â€” see [LICENSE](LICENSE) for details

---

## ğŸ™ Acknowledgments

- [FsiX](https://github.com/soweli-p/FsiX) â€” The original F# Interactive experience that inspired SageFs
- [PrettyPrompt](https://github.com/waf/PrettyPrompt) â€” Modern REPL experience
- [Ionide.ProjInfo](https://github.com/ionide/proj-info/) â€” Project file parsing
- [ModelContextProtocol](https://modelcontextprotocol.io/) â€” AI integration standard

---

**Enter Sage Mode. See everything. ğŸ¸**
